---
title: "Test Read-out File"
output: html_document
date: "2024-03-08"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Datacut with Modular Approach

```{r read-md, include=FALSE}
## Code to read and run a markdown file and save it

# demo_code = "~/datacutr/tests/read-out/demo_datacutr.R"
# cat(readLines(demo_code), sep = "\n") 

# output_source = function(code, context, ...) {
#   logo = file.path(R.home("doc"), "html", "logo.jpg")
#   if (context$label == "chunk-one") list(
#     rmarkdown::html_notebook_output_code("# R Code"),
#     paste("Custom output for chunk:", context$chunk.index),
#     rmarkdown::html_notebook_output_code("# R Logo"),
#     rmarkdown::html_notebook_output_img(logo)
#   )
# }
# 
# output_file = rmarkdown::render(
#   demo_code,
#   output_options = list(output_source = output_source),
#   quiet = TRUE
# )

```

```{r preprocess, include=FALSE}
# Demo Datacutr - Exploratory Work
# Creating data to be cut ------------------------------------------------
library(datacutr)
library(admiraldev)
library(dplyr)
library(lubridate)
library(stringr)
library(purrr)

source_data <- list(ds = datacutr_ds, dm = datacutr_dm, ae = datacutr_ae, sc = datacutr_sc, lb = datacutr_lb, fa = datacutr_fa, ts = datacutr_ts)

# Name: Datacut Template Code - Modular Approach
## Create DCUT ------------------------------------------------------------

dcut <- create_dcut(
  dataset_ds = source_data$ds,
  ds_date_var = DSSTDTC,
  filter = DSDECOD == "RANDOMIZATION",
  cut_date = "2022-06-04",
  cut_description = "Clinical Cutoff Date"
)

## Pre-processing of FA ----------------------------------------------------

## Update FA
source_data$fa <- source_data$fa %>%
  mutate(DCUT_TEMP_FAXDTC = case_when(
    FASTDTC != "" ~ FASTDTC,
    FADTC != "" ~ FADTC,
    TRUE ~ as.character(NA)
  ))

## Specify cut types ------------------------------------------------------

## Patient cut - cut applied will only be for patients existing in DCUT
patient_cut_list <- c("sc", "ds")

## Date cut - cut applied will be both for patients existing in DCUT, and date cut against DCUTDTM
date_cut_list <- rbind(
  c("ae", "AESTDTC"),
  c("lb", "LBDTC"),
  c("fa", "DCUT_TEMP_FAXDTC")
)

## No cut - data does not need to be cut
no_cut_list <- list(ts = source_data$ts)

## Create the cutting variables -------------------------------------------
## Conduct the patient cut ------------------------------------------------
patient_cut_data <- lapply(
  source_data[patient_cut_list], pt_cut,
  dataset_cut = dcut
)

## Conduct xxSTDTC or xxDTC Cut -------------------------------------------
date_cut_data <- pmap(
  .l = list(
    dataset_sdtm = source_data[date_cut_list[, 1]],
    sdtm_date_var = syms(date_cut_list[, 2])
  ),
  .f = date_cut,
  dataset_cut = dcut,
  cut_var = DCUTDTM
)

## Conduct DM special cut for DTH flags after DCUTDTM ---------------------
dm_cut <- special_dm_cut(
  dataset_dm = source_data$dm,
  dataset_cut = dcut,
  cut_var = DCUTDTM
)

## Apply the cut --------------------------------

cut_data <- purrr::map(
  c(patient_cut_data, date_cut_data, list(dm = dm_cut)),
  apply_cut,
  dcutvar = DCUT_TEMP_REMOVE,
  dthchangevar = DCUT_TEMP_DTHCHANGE
)

## Add on data which is not cut
final_data <- c(cut_data, no_cut_list, list(dcut = dcut))
```

``` {r tabulate function, include=FALSE}
library(rtables)
library(knitr)
library(kableExtra)

tabulate_data <- function(cut_data){
  cyc_num <- 1
  for (df in cut_data){
    print(knitr::kable(head(df),
                       caption = paste('Table to show ', 'FIGURE OUT A WAY TO SHOW THE NAME ', cyc_num)))
    cyc_num <- cyc_num + 1
}
}
```

### Create Datacut Dataset (DCUT)

After filtering the input DS dataset (based on the given filter condition), any records where the SDTMv date/time variable is on or before the datacut date/time (after imputations) will be returned in the output datacut dataset (DCUT). 

DCUT dataset:

```{r dcut}
#dcut 

knitr::kable(dcut)
```

### Patient Cut

Patient cut to an SDTMv dataset (i.e. subset SDTMv observations on patients included in the dataset_cut input dataset).

Input dataset plus a flag DCUT_TEMP_REMOVE to indicate which observations would be dropped when a patient level datacut is applied

Patient Cut dataset:

```{r pt_cut}
#patient_cut_data
library(DT)
trytable <- function(cut_data){
  cyc_num <- 1
  for (df in cut_data){
    return(datatable(cut_data$df))
    print(paste("Table ", cyc_num))
    cyc_num <- cyc_num + 1
}
}

#trytable(patient_cut_data)

#datatable(patient_cut_data$sc)

tabulate_data(patient_cut_data)
```

### Date Cut Data 

xxSTDTC or xxDTC Cut

Use to apply a datacut to either an xxSTDTC or xxDTC SDTM date variable. 
The datacut date from the datacut dataset is merged on to the input SDTMv dataset and renamed to `TEMP_DCUT_DCUTDTM`.
A flag `TEMP_DCUT_REMOVE` is added to the dataset to indicate the observations that would be removed when the cut is applied.

Note that this function applies a patient level datacut at the same time (using the `pt_cut()` function), and also imputes dates in the specified SDTMv dataset (using the `impute_sdtm()` function).

Input dataset plus a flag TEMP_DCUT_REMOVE to indicate which observations would be dropped when a datacut is applied

Data cut dataset:

```{r date_cut}
#date_cut_data

tabulate_data(date_cut_data)
```

### Special DM Cut Data 

Special DM Cut to reset Death variable information past cut date

Applies patient cut if patient not in source DCUT, as well as clearing death information within DM if death occurred after datacut date.

Input dataset plus a flag DCUT_TEMP_REMOVE to indicate which observations would be dropped when a datacut is applied, and a flag DCUT_TEMP_DTHCHANGE to indicate which observations have death occurring after data cut date for clearing.

Special DM cut data:

```{r dm_cut}
#dm_cut

knitr::kable(dm_cut) %>% 
  row_spec(which(dm_cut$DCUT_TEMP_DTHCHANGE == "Y"), color = 'white', background = 'red')%>%
  row_spec(which(dm_cut$DCUT_TEMP_REMOVE == "Y"), color = 'white', background = 'black')
```

### Cut Data 

Cut data:

```{r cut_data, include=FALSE}
#cut_data

tabulate_data(cut_data)
```

### Final Data

Uncut data added to the cut data.

Final data:

```{r final_cut, include=FALSE}
#final_data

tabulate_data(final_data)
```
