---
title: "Test Read-out File"
date: "2024-03-08"
output: 
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '3'
  html_notebook:
      code_folding: hide
      theme: united
      toc: yes
      toc_depth: 3
      toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r read-md, include=FALSE}
## Code to read and run a markdown file and save it

# demo_code = "~/datacutr/tests/read-out/demo_datacutr.R"
# cat(readLines(demo_code), sep = "\n") 

# output_source = function(code, context, ...) {
#   logo = file.path(R.home("doc"), "html", "logo.jpg")
#   if (context$label == "chunk-one") list(
#     rmarkdown::html_notebook_output_code("# R Code"),
#     paste("Custom output for chunk:", context$chunk.index),
#     rmarkdown::html_notebook_output_code("# R Logo"),
#     rmarkdown::html_notebook_output_img(logo)
#   )
# }
# 
# output_file = rmarkdown::render(
#   demo_code,
#   output_options = list(output_source = output_source),
#   quiet = TRUE
# )

```

```{r preprocess, include=FALSE}
## Datacut with Modular Approach
# Demo Datacutr - Exploratory Work
# Creating data to be cut ------------------------------------------------
library(datacutr)
library(admiraldev)
library(dplyr)
library(lubridate)
library(stringr)
library(purrr)

source_data <- list(ds = datacutr_ds, dm = datacutr_dm, ae = datacutr_ae, sc = datacutr_sc, lb = datacutr_lb, fa = datacutr_fa, ts = datacutr_ts)

# Name: Datacut Template Code - Modular Approach
## Create DCUT ------------------------------------------------------------

dcut <- create_dcut(
  dataset_ds = source_data$ds,
  ds_date_var = DSSTDTC,
  filter = DSDECOD == "RANDOMIZATION",
  cut_date = "2022-06-04",
  cut_description = "Clinical Cutoff Date"
)

## Pre-processing of FA ----------------------------------------------------

## Update FA
source_data$fa <- source_data$fa %>%
  mutate(DCUT_TEMP_FAXDTC = case_when(
    FASTDTC != "" ~ FASTDTC,
    FADTC != "" ~ FADTC,
    TRUE ~ as.character(NA)
  ))

## Specify cut types ------------------------------------------------------

## Patient cut - cut applied will only be for patients existing in DCUT
patient_cut_list <- c("sc", "ds")

## Date cut - cut applied will be both for patients existing in DCUT, and date cut against DCUTDTM
date_cut_list <- rbind(
  c("ae", "AESTDTC"),
  c("lb", "LBDTC"),
  c("fa", "DCUT_TEMP_FAXDTC")
)

## No cut - data does not need to be cut
no_cut_list <- list(ts = source_data$ts)

## Create the cutting variables -------------------------------------------
## Conduct the patient cut ------------------------------------------------
patient_cut_data <- lapply(
  source_data[patient_cut_list], pt_cut,
  dataset_cut = dcut
)

## Conduct xxSTDTC or xxDTC Cut -------------------------------------------
date_cut_data <- pmap(
  .l = list(
    dataset_sdtm = source_data[date_cut_list[, 1]],
    sdtm_date_var = syms(date_cut_list[, 2])
  ),
  .f = date_cut,
  dataset_cut = dcut,
  cut_var = DCUTDTM
)

## Conduct DM special cut for DTH flags after DCUTDTM ---------------------
dm_cut <- special_dm_cut(
  dataset_dm = source_data$dm,
  dataset_cut = dcut,
  cut_var = DCUTDTM
)

## Apply the cut --------------------------------

cut_data <- purrr::map(
  c(patient_cut_data, date_cut_data, list(dm = dm_cut)),
  apply_cut,
  dcutvar = DCUT_TEMP_REMOVE,
  dthchangevar = DCUT_TEMP_DTHCHANGE
)

## Add on data which is not cut
final_data <- c(cut_data, no_cut_list, list(dcut = dcut))
```

``` {r tabulate function, include=FALSE}
library(rtables)
library(knitr)
library(kableExtra)

# Tabulate the data
# tabulate_data <- function(cut_data){
#   cyc_num <- 1
#   for (df in cut_data){
#     print(knitr::kable(head(df),
#                        caption = paste('Table to show ', 'FIGURE OUT A WAY TO SHOW THE NAME ', cyc_num)))
#     cyc_num <- cyc_num + 1
# }
# }

# Make table function to go into tabs
# make_table <- function(table){
#   knitr::kable(table) %>%
#           row_spec(which(table$DCUT_TEMP_REMOVE == "Y"), color = 'black', background = '#E8E7E7')
# }

# Create tabs in the html
df_tabs <- function(data){
  cyc_num <- 1
  for (df in data){
    name <- names(data)[cyc_num]
    cat("####", name, " \n")
    if (exists("DCUT_TEMP_REMOVE", where = df)){
      x <- length(which(df$DCUT_TEMP_REMOVE == "Y"))
      cat(paste("Number of records removed in ", name, " is ", x))
    } 
    print(knitr::kable(df))
    cat(' \n\n')
    cyc_num <- cyc_num + 1
  }
}

# Tabulate special dm cut and highlight modified
tabulate_dm <- function(cut_data){
  knitr::kable(cut_data, align = 'c', booktabs = TRUE) %>% 
  row_spec(which(cut_data$DCUT_TEMP_DTHCHANGE == "Y"), color = 'black', background = '#FCB6B6')%>%
  row_spec(which(cut_data$DCUT_TEMP_REMOVE == "Y"), color = 'black', background = '#E8E7E7') %>% 
  kable_styling(font_size = 12)
}

sum_dm <- function(cut_data){
  x <- length(which(cut_data$DCUT_TEMP_DTHCHANGE == "Y"))
  y <- length(which(cut_data$DCUT_TEMP_REMOVE == "Y"))
  print(paste("Number of records with modified death dates: ", x))
  print(paste("Number of records removed: ", y))
}
```

## Create Datacut Dataset (DCUT)

After filtering the input DS dataset (based on the given filter condition), any records where the SDTMv date/time variable is on or before the datacut date/time (after imputations) will be returned in the output datacut dataset (DCUT). 

### DCUT dataset:

```{r dcut, echo = FALSE}
knitr::kable(dcut)
```

## Patient Cut

Patient cut to an SDTMv dataset (i.e. subset SDTMv observations on patients included in the dataset_cut input dataset).

Input dataset plus a flag DCUT_TEMP_REMOVE to indicate which observations would be dropped when a patient level datacut is applied

### Patient Cut Datasets {.tabset}
```{r, results='asis', echo = FALSE}
df_tabs(patient_cut_data)
```


## Date Cut 

xxSTDTC or xxDTC Cut

Use to apply a datacut to either an xxSTDTC or xxDTC SDTM date variable. 
The datacut date from the datacut dataset is merged on to the input SDTMv dataset and renamed to `TEMP_DCUT_DCUTDTM`.
A flag `TEMP_DCUT_REMOVE` is added to the dataset to indicate the observations that would be removed when the cut is applied.

Note that this function applies a patient level datacut at the same time (using the `pt_cut()` function), and also imputes dates in the specified SDTMv dataset (using the `impute_sdtm()` function).

Input dataset plus a flag TEMP_DCUT_REMOVE to indicate which observations would be dropped when a datacut is applied

### Date Cut Datasets {.tabset}
```{r, results='asis', echo = FALSE}
df_tabs(date_cut_data)
```

## Special DM Cut 

Special DM Cut to reset Death variable information past cut date

Applies patient cut if patient not in source DCUT, as well as clearing death information within DM if death occurred after datacut date.

Input dataset plus a flag DCUT_TEMP_REMOVE to indicate which observations would be dropped when a datacut is applied, and a flag DCUT_TEMP_DTHCHANGE to indicate which observations have death occurring after data cut date for clearing.

### Special DM cut dataset:
```{r dm_cut, echo = FALSE}
tabulate_dm(dm_cut)

sum_dm(dm_cut)
```

For ease of interpretation, the records where death dates have been modified are flagged red. The records that have been removed are grey.

## Cut Data 

Data after the cut has been applied.

### Cut datasets {.tabset}
```{r, results='asis', echo = FALSE}

df_tabs(cut_data)
```

## Final Data

Uncut data added to the cut data.

### Final datasets {.tabset}
```{r, results='asis', echo = FALSE}

df_tabs(final_data)
```
